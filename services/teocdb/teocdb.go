// Copyright 2019 Teonet-go authors.  All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package teocdb (teo-cdb) is the Teonet database service package
//
// Install this go package:
//   go get github.com/kirill-scherba/teonet-go/services/teoregistry
//
// Data base organisation
//
// This service uses ScyllaDB. If you install this service manually you need
// install ScyllaDB. Run Scylla in Docker:
//
//   https://www.scylladb.com/download/open-source/#docker
//
// Before you execute application which used this package you need install
// database schemas. Launch `cqlsh`:
//   docker exec -it scylla cqlsh
// and execute next commands:
/*
	create keyspace teocdb with replication = { 'class' : 'SimpleStrategy', 'replication_factor' : 3 };
	create table teocdb.map(key text, data blob, PRIMARY KEY(key));
*/
//
package teocdb

import (
	"encoding/binary"
	"fmt"

	"github.com/gocql/gocql"
)

// Key value database commands
const (
	CmdSetB = 129 // Set (insert or update) binary {key,value} to database
	CmdSet  = 130 // Set (insert or update) text or json \"key,value\" to database
	CmdGet  = 131 // Get key value and send answer with value in text or json format
	CmdList = 132 // Get list of keys (by not complete key) and send answer with array of keys in text or json format
)

// TeoConnector is teonet connector interface. It may be servers (*Teonet) or
// clients (*TeoLNull) connector and must conain SendTo method.
type TeoConnector interface {
	SendTo(peer string, cmd byte, data []byte) (int, error)
}

// Teocdb is teocdb packet receiver
type Teocdb struct {
	Session *gocql.Session
}

// JSONData is key value packet in json format
type JSONData struct {
	Key   string      `json:"key"`
	ID    interface{} `json:"id"`
	Value interface{} `json:"value"`
}

// Connect to the cql cluster and return teocdb receiver
func Connect(hosts ...string) (tdb *Teocdb, err error) {
	tdb = &Teocdb{}
	cluster := gocql.NewCluster(func() (h []string) {
		if h = hosts; len(h) == 0 {
			h = []string{"172.17.0.2", "172.17.0.3", "172.17.0.4"}
		}
		return
	}()...)
	cluster.Keyspace = "teocdb"
	cluster.Consistency = gocql.Quorum
	tdb.Session, _ = cluster.CreateSession()

	// Create keyspace and table
	const mapSchema = `
		// create KEYSPACE IF NOT EXISTS teocdb WITH replication = {
		// 	'class' : 'SimpleStrategy',
		// 	'replication_factor' : 3
		// };
		create TABLE IF NOT EXISTS teocdb.map(
			key text,
			data blob,
			PRIMARY KEY(key)
		)`
	if err = tdb.execStmt(tdb.Session, mapSchema); err != nil {
		//t.Fatal("create table:", err)
	}
	return
}

// ExecStmt executes a statement string.
func (tdb *Teocdb) execStmt(s *gocql.Session, stmt string) error {
	q := s.Query(stmt).RetryPolicy(nil)
	defer q.Release()
	return q.Exec()
}

// Close teocdb connection
func (tdb *Teocdb) Close() {
	tdb.Session.Close()
}

// BinaryData is key value packet in binary format
type BinaryData struct {
	Key   string
	ID    int
	Value []byte
}

// MarshalBinary encodes the receiver into a binary form and returns the result.
func (bd *BinaryData) MarshalBinary() (data []byte, err error) {
	l := make([]byte, 4)
	binary.LittleEndian.PutUint32(l, uint32(len(bd.Key)))
	data = append(append(l, []byte(bd.Key)...), bd.Value...)
	return
}

// UnmarshalBinary must be able to decode the form generated by MarshalBinary.
// UnmarshalBinary must copy the data if it wishes to retain the data
// after returning.
func (bd *BinaryData) UnmarshalBinary(data []byte) (err error) {
	l := binary.LittleEndian.Uint32(data[:4]) + 4
	bd.Key = string(data[4:l])
	bd.Value = data[l:]
	return
}

// Set is clients api function to insert or update binary {key,value} buffer in
// teonet database. This function sends teocdb.CmdSetB(#129) command to teo-cdb
// teonet service which save it in key/value database.
func Set(con TeoConnector, key string, value []byte) (err error) {
	if data, err := (&BinaryData{Key: key, Value: value}).MarshalBinary(); err == nil {
		_, err = con.SendTo("teo-cdb", CmdSetB, data)
	}
	return
}

// Update key value
func (tdb *Teocdb) Update(key string, value []byte) (err error) {
	if err = tdb.Session.Query(`UPDATE map SET data = ? WHERE key = ?`,
		value, key).Exec(); err != nil {
		fmt.Printf("Insert Error: %s\n", err.Error())
	}
	return
}

// Get value by key
func (tdb *Teocdb) Get(key string) (data []byte, err error) {
	if err := tdb.Session.Query(`SELECT data FROM map WHERE key = ? LIMIT 1`,
		key).Consistency(gocql.One).Scan(&data); err != nil {
		fmt.Printf("Get Error: %s\n", err.Error())
	}
	return
}

// List read and return array of all keys connected to selected key
func (tdb *Teocdb) List(key string) (keyAr []string, err error) {
	var keyOut string
	iter := tdb.Session.Query(`
		SELECT key FROM map WHERE key >= ? and key < ?
		ALLOW FILTERING`,
		key, key+"a").Iter()
	for iter.Scan(&keyOut) {
		fmt.Println("key:", keyOut)
		keyAr = append(keyAr, keyOut)
	}
	return
}
